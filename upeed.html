<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Speed - Final Version</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: #1a1a1a; overflow: hidden; position: fixed;
      font-family: sans-serif;
    }
    .game-board { 
      height: 100dvh; display: flex; flex-direction: column; 
      justify-content: space-between; padding: 10px 0; box-sizing: border-box; 
    }
    #p2-side, #p1-side, #field-wrapper {
      width: 100%; display: flex; flex-direction: column;
      align-items: center; justify-content: center; flex: 1; 
    }
    .player-area { 
      display: flex; justify-content: center; gap: 2vw; 
      width: 100%; min-height: 25vw;
    }
    #p2-side { transform: rotate(180deg); }

    .card {
      width: 16vw; max-width: 70px; height: 24vw; max-height: 100px;
      border-radius: 10px; border: 2px solid #fff;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      font-size: 6vw; font-weight: bold; background: white; color: black;
      box-shadow: 0 4px 6px rgba(0,0,0,0.4); user-select: none; touch-action: none;
      z-index: 10; cursor: grab; position: relative;
    }
    
    .card.stuck { filter: grayscale(100%) brightness(0.6); opacity: 0.7; }
    .card.dragging { position: fixed !important; z-index: 99999 !important; cursor: grabbing; pointer-events: none; margin: 0 !important; }
    .card.red { background: #ff4d4d; color: white; }
    .card.blue { background: #4d94ff; color: white; }
    .card.yellow { background: #ffd11a; color: black; }
    .card.green { background: #2eb82e; color: white; }
    .underline { border-bottom: 4px solid currentColor; line-height: 0.8; }

    #field-wrapper { flex: 1.2; flex-direction: row; gap: 3vw; position: relative; }
    .field-area { display: flex; justify-content: center; gap: 4vw; border: 2px dashed #444; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 15px; min-width: 65%; }
    #field .card:nth-child(2) { transform: rotate(180deg); }
    
    .deck-info { font-size: 12px; color: #888; margin-top: 5px; font-weight: bold; }
    #status-msg { position: absolute; width: 100%; text-align: center; top: -35px; color: #ffd11a; font-weight: bold; font-size: 16px; z-index: 200; }
    
    .action-btn {
      display: none; position: absolute; right: 5%; 
      padding: 15px 10px; background: #444; color: white; 
      border: 2px solid #fff; border-radius: 5px; font-weight: bold; 
      cursor: pointer; transform: rotate(90deg); z-index: 100;
    }
    #new-game-btn { background: #ff4d4d; top: 40%; transform: rotate(0deg); right: auto; left: 50%; transform: translate(-50%, -50%); padding: 20px 40px; font-size: 20px; }
  </style>
</head>
<body>

<div class="game-board">
  <div id="p2-side">
    <div id="player2" class="player-area"></div>
    <div class="deck-info">Deck: <span id="p2-count"></span></div>
  </div>

  <div id="field-wrapper">
    <div id="status-msg"></div>
    <button id="refresh-btn" class="action-btn" onclick="game.startRefreshProcess()">REFRESH</button>
    <button id="new-game-btn" class="action-btn" onclick="game.startNewGame()">NEW GAME</button>
    <div class="field-area" id="field"></div>
  </div>

  <div id="p1-side">
    <div class="deck-info">Deck: <span id="p1-count"></span></div>
    <div id="player1" class="player-area"></div>
  </div>
</div>

<script>
class SpeedGame {
  constructor() {
    this.colors = ['red', 'blue', 'yellow', 'green'];
    this.activePointers = new Map();
    this.isLocked = false;
    this.isGameOver = false;
    this.waitingForP1 = false;
    this.waitingForP2 = false;
    this.startNewGame();
  }

  startNewGame() {
    this.isGameOver = false;
    this.isLocked = false;
    this.waitingForP1 = false;
    this.waitingForP2 = false;
    document.getElementById('new-game-btn').style.display = 'none';
    document.getElementById('status-msg').textContent = "";

    let masterDeck = [];
    this.colors.forEach(color => {
      for (let i = 0; i <= 9; i++) masterDeck.push({ color, num: i });
    });
    masterDeck.sort(() => Math.random() - 0.5);
    this.field = [masterDeck.pop(), masterDeck.pop()];
    this.p1Deck = masterDeck.splice(0, 19);
    this.p2Deck = masterDeck.splice(0, 19);
    this.player1Open = []; this.player2Open = [];
    for (let i = 0; i < 4; i++) {
      this.player1Open.push(this.p1Deck.pop());
      this.player2Open.push(this.p2Deck.pop());
    }
    this.updateUI();
  }

  updateUI() {
    this.renderPlayer('player1', this.player1Open);
    this.renderPlayer('player2', this.player2Open);
    this.renderField();
    document.getElementById('p1-count').textContent = this.p1Deck.length;
    document.getElementById('p2-count').textContent = this.p2Deck.length;
    if (!this.isGameOver) this.checkStalemate();
  }

  renderPlayer(id, cards) {
    const area = document.getElementById(id);
    area.innerHTML = '';
    cards.forEach((card, idx) => {
      if (!card) return;
      const el = this.createCardEl(card);
      el.dataset.index = idx;
      el.dataset.owner = id;
      this.makeDraggable(el);
      area.appendChild(el);
    });
  }

  renderField() {
    const area = document.getElementById('field');
    area.innerHTML = '';
    this.field.forEach((card, idx) => {
      const el = this.createCardEl(card);
      el.id = `target-${idx}`;
      
      let shouldGray = (this.isLocked || document.getElementById('refresh-btn').style.display === 'block');
      if (card.colorFixed || this.isGameOver) shouldGray = false;

      if (shouldGray) el.classList.add('stuck');
      area.appendChild(el);
    });
  }

  createCardEl(card) {
    const el = document.createElement('div');
    el.className = `card ${card.color}`;
    const numEl = document.createElement('span');
    numEl.textContent = card.num;
    if (card.num === 6 || card.num === 9) numEl.className = 'underline';
    el.appendChild(numEl);
    return el;
  }

  makeDraggable(el) {
    el.addEventListener('pointerdown', (e) => {
      if (this.isGameOver) return; // ゲーム終了後は何もしない
      
      const owner = el.dataset.owner;
      if (this.isLocked) {
        if (!((owner === 'player1' && this.waitingForP1) || (owner === 'player2' && this.waitingForP2))) return;
      }
      const rect = el.getBoundingClientRect();
      this.activePointers.set(e.pointerId, {
        el, owner, offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top,
        originalParent: el.parentElement
      });
      el.classList.add('dragging');
      document.body.appendChild(el);
      if (owner === 'player2') el.style.transform = 'rotate(180deg)';
      this.updateCardPos(el, e.clientX, e.clientY, e.pointerId);
      el.setPointerCapture(e.pointerId);
    });

    el.addEventListener('pointermove', (e) => {
      const data = this.activePointers.get(e.pointerId);
      if (data) this.updateCardPos(data.el, e.clientX, e.clientY, e.pointerId);
    });

    el.addEventListener('pointerup', (e) => {
      const data = this.activePointers.get(e.pointerId);
      if (data) {
        data.el.classList.remove('dragging');
        data.el.style.transform = '';
        this.handleDrop(data.el, e.clientX, e.clientY, data.originalParent);
        this.activePointers.delete(e.pointerId);
      }
    });
  }

  updateCardPos(el, x, y, id) {
    const data = this.activePointers.get(id);
    el.style.left = (x - data.offsetX) + 'px';
    el.style.top = (y - data.offsetY) + 'px';
  }

  canPlay(cardData, targetCard) {
    if (!cardData || !targetCard) return false;
    if (cardData.color === targetCard.color) {
      if (targetCard.num === 9 && cardData.num === 0) return true;
      return cardData.num > targetCard.num;
    } else {
      return cardData.num === targetCard.num;
    }
  }

  checkStalemate() {
    if (this.isLocked || this.isGameOver) return; 
    const p1Valid = this.player1Open.filter(c => c !== null);
    const p2Valid = this.player2Open.filter(c => c !== null);
    const anyPlayable = [...p1Valid, ...p2Valid].some(card => 
      this.field.some(fCard => this.canPlay(card, fCard))
    );
    const btn = document.getElementById('refresh-btn');
    const msg = document.getElementById('status-msg');
    if (!anyPlayable) {
      btn.style.display = 'block';
      msg.textContent = "STALEMATE!";
      this.renderField();
    } else {
      btn.style.display = 'none';
      msg.textContent = "";
    }
  }

  startRefreshProcess() {
    this.isLocked = true;
    const msg = document.getElementById('status-msg');
    document.getElementById('refresh-btn').style.display = 'none';

    const p1HasDeck = this.p1Deck.length > 0;
    const p2HasDeck = this.p2Deck.length > 0;

    if (p1HasDeck) { this.field[0] = this.p1Deck.pop(); this.field[0].colorFixed = true; }
    if (p2HasDeck) { this.field[1] = this.p2Deck.pop(); this.field[1].colorFixed = true; }

    this.waitingForP1 = !p1HasDeck;
    this.waitingForP2 = !p2HasDeck;

    if (!this.waitingForP1 && !this.waitingForP2) {
      msg.textContent = "READY...";
      setTimeout(() => this.finishRefresh(), 1000);
    } else {
      msg.textContent = (this.waitingForP1 && this.waitingForP2) ? "BOTH PLAYERS: CHOOSE A CARD" : (this.waitingForP1 ? "P1: CHOOSE A CARD" : "P2: CHOOSE A CARD");
      this.updateUI();
    }
  }

  finishRefresh() {
    if (this.isGameOver) return;
    const msg = document.getElementById('status-msg');
    msg.textContent = "GO!";
    setTimeout(() => {
      this.isLocked = false;
      this.waitingForP1 = false;
      this.waitingForP2 = false;
      msg.textContent = "";
      this.field.forEach(c => delete c.colorFixed);
      this.updateUI();
    }, 600);
  }

  handleDrop(el, dropX, dropY, originalParent) {
    const owner = el.dataset.owner;
    const idx = parseInt(el.dataset.index);
    const openCards = (owner === 'player1') ? this.player1Open : this.player2Open;
    const cardData = openCards[idx];

    for (let i = 0; i < 2; i++) {
      const targetEl = document.getElementById(`target-${i}`);
      const rect = targetEl.getBoundingClientRect();

      if (dropX >= rect.left && dropX <= rect.right && dropY >= rect.top && dropY <= rect.bottom) {
        if ((owner === 'player1' && this.waitingForP1) || (owner === 'player2' && this.waitingForP2)) {
          if (this.field[i].colorFixed) continue; 
          cardData.colorFixed = true; // 色を固定
          this.field[i] = cardData;
          if (owner === 'player1') this.waitingForP1 = false;
          if (owner === 'player2') this.waitingForP2 = false;
          this.refillHand(owner, idx);
          if (!this.waitingForP1 && !this.waitingForP2) this.finishRefresh();
          else {
            document.getElementById('status-msg').textContent = "WAITING FOR OTHER...";
            this.updateUI(); 
          }
          return;
        } 
        else if (!this.isLocked && this.canPlay(cardData, this.field[i])) {
          this.field[i] = cardData;
          this.refillHand(owner, idx);
          break;
        }
      }
    }
    originalParent.appendChild(el);
    this.updateUI();
  }

  refillHand(player, idx) {
    const deck = (player === 'player1') ? this.p1Deck : this.p2Deck;
    const open = (player === 'player1') ? this.player1Open : this.player2Open;
    if (deck.length > 0) open[idx] = deck.pop();
    else open[idx] = null;
    
    if (open.every(c => c === null)) {
      this.isGameOver = true;
      const msg = document.getElementById('status-msg');
      msg.textContent = player.toUpperCase() + " WIN!";
      document.getElementById('new-game-btn').style.display = 'block';
      document.getElementById('refresh-btn').style.display = 'none';
      this.renderField(); // 最後のカードの色を確定させる
    }
  }
}
const game = new SpeedGame();
</script>
</body>
</html>