<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
	/* 画面全体の固定 */
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #222;
    overflow: hidden;
    position: fixed;
  }

  /* ゲーム盤全体 */
  .game-board { 
    /* svh/dvh を使うことでスマホのツールバー被りを防ぐ */
    height: 100vh;
    height: 100dvh; 
    display: flex; 
    flex-direction: column; 
    /* 全体を画面内に均等配置 */
    justify-content: space-between; 
    padding: 5px 0;
    box-sizing: border-box; 
  }

  /* 各プレイヤー・中央エリアをコンテナとして定義 */
  #p2-side, #p1-side, #field-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    /* 各セクションが重なり合わないように調整 */
    justify-content: center;
    flex: 1; 
  }

  /* カードのレスポンシブ化 */
  .card {
    width: 15vw; 
    max-width: 60px; 
    height: 22.5vw; 
    max-height: 90px;
    border-radius: 8px; 
    border: 1.5px solid #fff;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center;
    font-size: 5vw;
    font-weight: bold; 
    background: white; 
    color: black;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3); 
    user-select: none;
    /* ドラッグ時のバグ防止 */
    touch-action: none; 
  }

  /* プレイヤーエリア */
  .player-area { 
    display: flex; 
    justify-content: center; 
    gap: 2vw; 
    width: 100%;
    /* エリアが潰れないように高さを確保 */
    min-height: 23vw;
  }

  #player2 { transform: rotate(180deg); }

  /* 中央エリアの調整 */
  #field-wrapper {
    flex: 1.2; /* 中央を少しだけ広く取る */
    flex-direction: row; /* REFRESHボタンを横に並べるため */
    gap: 2vw;
  }

  .field-area { 
    display: flex; 
    justify-content: center; 
    gap: 3vw; 
    border: 1px dashed #555; 
    padding: 8px; 
    background: rgba(255,255,255,0.05);
    border-radius: 10px;
  }

  /* 枚数表示 */
  .deck-info { 
    font-size: 11px; 
    text-align: center; 
    color: #888; 
    margin: 2px 0;
  }


  /* カードの色 */
  .card.red { background: #ff4d4d; color: white; }
  .card.blue { background: #4d94ff; color: white; }
  .card.yellow { background: #ffd11a; color: black; }
  .card.green { background: #2eb82e; color: white; }

  /* アンダーバー */
  .underline {
    border-bottom: 3px solid currentColor;
    line-height: 0.9;
    display: inline-block;
  }

  /* P2側のカードを逆さにする */
  #field .card:nth-child(2) {
    transform: rotate(180deg);
  }

  /* リフレッシュボタンのスタイル（横向き） */
  #refresh-btn {
    display: none;
    transform: rotate(90deg);
    white-space: nowrap;
    padding: 8px 15px;
    font-size: 12px;
    border-radius: 5px;
    border: 1px solid #fff;
    background: #444;
    color: #fff;
    cursor: pointer;
  }

	/* 場のカードをグレーアウトさせるスタイル */
	.card.gray-out {
	  filter: grayscale(100%);
	  opacity: 0.6;
	  border-color: #555;
	  transition: filter 0.5s, opacity 0.5s;
	}
</style></head>
<body>

<div class="game-board">
  <div id="p2-side">
    <div id="player2" class="player-area"></div>
    <div class="deck-info" style="transform: rotate(180deg);">P2 Deck: <span id="p2-count">0</span></div>
  </div>

  <div id="field-wrapper" style="display: flex; align-items: center; justify-content: center;">
    <div class="field-area" id="field"></div>
    <div id="refresh-container">
      <button id="refresh-btn">REFRESH</button>
    </div>
  </div>

  <div id="p1-side">
    <div class="deck-info">P1 Deck: <span id="p1-count">0</span></div>
    <div id="player1" class="player-area"></div>
  </div>
</div>

<script>
const COLORS = ['red', 'blue', 'yellow', 'green'];
const VALUES = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

class Game {
  constructor() {
    this.deck = [];
    this.player1 = { hand: [], open: [] };
    this.player2 = { hand: [], open: [] };
    this.field = [];
    this.initGame();
  }

  initGame() {
    this.deck = [];
    COLORS.forEach(color => {
      VALUES.forEach(value => {
        this.deck.push({ color, value });
      });
    });
    for (let i = this.deck.length - 1; i > 0; i--) {
      const r = Math.floor(Math.random() * (i + 1));
      [this.deck[i], this.deck[r]] = [this.deck[r], this.deck[i]];
    }
    this.deal();
  }

  deal() {
    this.player1.hand = this.deck.slice(0, 20);
    this.player2.hand = this.deck.slice(20, 40);
    this.player1.open = this.player1.hand.splice(0, 4);
    this.player2.open = this.player2.hand.splice(0, 4);
    this.field.push(this.player1.hand.shift());
    this.field.push(this.player2.hand.shift());
  }
}

class GameUI extends Game {
	constructor() {
    super();
    // ★フラグを確実に初期化
    this.p1Forced = false;
    this.p2Forced = false;
    
    this.updateUI();
    document.getElementById('refresh-btn').onclick = () => this.handleRefresh();
  }
  // ★重要：追加（判定ロジック）
  canPlay(myCard, fieldCard) {
    if (!myCard || !fieldCard) return false;
    return (myCard.value === fieldCard.value) || 
           (myCard.color === fieldCard.color && myCard.value > fieldCard.value);
  }

	addDragListeners(el, playerNum, index) {
    let isDragging = false;
    let dragClone = null;
    let startX, startY;

    // ハンドラを関数として定義
    const onMove = (e) => {
      if (!isDragging || !dragClone) return;
      // スマホのスクロールを防止
      if (e.cancelable) e.preventDefault();
      
      const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
      const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);

      dragClone.style.left = (clientX - startX) + 'px';
      dragClone.style.top = (clientY - startY) + 'px';
    };

    const onEnd = (e) => {
      if (!isDragging) return;
      isDragging = false;
      
      const clientX = (e.changedTouches ? e.changedTouches[0].clientX : e.clientX);
      const clientY = (e.changedTouches ? e.changedTouches[0].clientY : e.clientY);

      this.checkDrop(clientX, clientY, playerNum, index);

      if (dragClone) {
        dragClone.remove();
        dragClone = null;
      }
      el.style.opacity = "1";

      // イベントリスナーを解除（windowを汚さないため）
      window.removeEventListener('mousemove', onMove);
      window.removeEventListener('mouseup', onEnd);
      window.removeEventListener('touchmove', onMove);
      window.removeEventListener('touchend', onEnd);

      this.updateUI(); 
    };

		const onStart = (e) => {
	    // 複数指のタッチは無視
	    if (e.touches && e.touches.length > 1) return;

	    // ★重要：クリックした「その瞬間」に、そのカードの位置を取得する
	    const rect = el.getBoundingClientRect(); 
	    
	    isDragging = true;
	    const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
	    const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
	    
	    // 指の位置とカードの左上端との距離を計算
	    startX = clientX - rect.left;
	    startY = clientY - rect.top;

	    // クローン（身代わり）を作成
	    dragClone = el.cloneNode(true);
	    dragClone.style.position = 'fixed';
	    dragClone.style.left = rect.left + 'px';
	    dragClone.style.top = rect.top + 'px';
	    dragClone.style.width = rect.width + 'px';
	    dragClone.style.height = rect.height + 'px';
	    dragClone.style.zIndex = "1000";
	    dragClone.style.pointerEvents = "none";
	    dragClone.style.opacity = "0.8";

	    // Player 2側のカードなら逆さまを維持
	    if (playerNum === 2) {
	      dragClone.style.transform = "rotate(180deg)";
	    } else {
	      dragClone.style.transform = "rotate(0deg)";
	    }

	    document.body.appendChild(dragClone);
	    el.style.opacity = "0.3";

	    window.addEventListener('mousemove', onMove, { passive: false });
	    window.addEventListener('mouseup', onEnd);
	    window.addEventListener('touchmove', onMove, { passive: false });
	    window.addEventListener('touchend', onEnd);
	  };
    // 要素自体にはstartイベントのみ登録
    el.addEventListener('mousedown', onStart);
    el.addEventListener('touchstart', onStart, { passive: false });
  }

  checkDrop(x, y, playerNum, index) {
    const fieldElements = document.querySelectorAll('.field-card');
    fieldElements.forEach((fieldEl, fIndex) => {
      const rect = fieldEl.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        this.playCard(playerNum, index, fIndex);
      }
    });
  }

  checkWin(playerNum) {
    const player = (playerNum === 1) ? this.player1 : this.player2;
    if (player.open.length === 0 && player.hand.length === 0) {
      setTimeout(() => {
        alert(`プレイヤー ${playerNum} の勝利です！`);
        location.reload();
      }, 100);
    }
  }

	createCardElement(card, playerNum, index, isField = false) {
    const div = document.createElement('div');
    div.className = `card ${card.color} ${isField ? 'field-card' : ''}`;
    
    // 数字を表示する要素を作成
    const span = document.createElement('span');
    span.textContent = card.value;
    
    // 6または9の場合にアンダーバー用クラスを付与
    if (card.value === 6 || card.value === 9) {
      span.className = 'underline';
    }
    
    div.appendChild(span);
    
    if (!isField) {
      this.addDragListeners(div, playerNum, index);
    }
    return div;
  }

	// 強制モードの判定を含めた playCard
  playCard(playerNum, openIndex, targetFieldIndex) {
    const player = (playerNum === 1) ? this.player1 : this.player2;
    const isMyForcedMode = (playerNum === 1) ? this.p1Forced : this.p2Forced;
    
    const myCard = player.open[openIndex];
    const targetFieldCard = this.field[targetFieldIndex];

    // 「通常のルールに合致」または「自分が強制モード中」なら受理
    if (isMyForcedMode || this.canPlay(myCard, targetFieldCard)) {
      this.field[targetFieldIndex] = myCard;

      if (player.hand.length > 0) {
        player.open[openIndex] = player.hand.shift();
      } else {
        player.open.splice(openIndex, 1);
      }

      // 自分の強制モードを解除
      if (playerNum === 1) this.p1Forced = false;
      if (playerNum === 2) this.p2Forced = false;

      // 両方の強制モードが終了したらボタンの色を戻す
      if (!this.p1Forced && !this.p2Forced) {
        document.getElementById('refresh-btn').style.background = "#333";
      }

      this.checkWin(playerNum);
      this.updateUI();
    } else {
      console.log("出せません。通常ルールに合致しないか、強制モードではありません。");
    }
  }

  handleRefresh() {
    let msg = "";

    // P1の処理
    if (this.player1.hand.length > 0) {
      this.field[0] = this.player1.hand.shift();
      this.p1Forced = false;
      msg += "P1: 手札から補充しました。\n";
    } else {
      this.p1Forced = true;
      msg += "P1: 手札なし。好きなカードを出せます。\n";
    }

    // P2の処理
    if (this.player2.hand.length > 0) {
      this.field[1] = this.player2.hand.shift();
      this.p2Forced = false;
      msg += "P2: 手札から補充しました。\n";
    } else {
      this.p2Forced = true;
      msg += "P2: 手札なし。好きなカードを出せます。\n";
    }

    if (this.p1Forced || this.p2Forced) {
      document.getElementById('refresh-btn').style.background = "#ff4d4d";
    }
    
    alert(msg);
    this.updateUI();
  }

	checkStalemate() {
	  // どちらかが「好きなの選べるモード」ならグレーアウトさせない
	  if (this.p1Forced || this.p2Forced) {
	    document.getElementById('refresh-btn').style.display = 'block';
	    return;
	  }

	  const p1CanPlay = this.player1.open.some(card => 
	    this.canPlay(card, this.field[0]) || this.canPlay(card, this.field[1])
	  );
	  const p2CanPlay = this.player2.open.some(card => 
	    this.canPlay(card, this.field[0]) || this.canPlay(card, this.field[1])
	  );

	  const refreshBtn = document.getElementById('refresh-btn');
	  const fieldCards = document.querySelectorAll('#field .card'); // 場のカードを取得

	  if (!p1CanPlay && !p2CanPlay) {
	    // 【手詰まり時】ボタンを表示し、場のカードをグレーにする
	    refreshBtn.style.display = 'block';
	    fieldCards.forEach(card => card.classList.add('gray-out'));
	  } else {
	    // 【通常時】ボタンを隠し、場のカードの色を戻す
	    refreshBtn.style.display = 'none';
	    fieldCards.forEach(card => card.classList.remove('gray-out'));
	  }
	}

  updateUI() {
    const p1Area = document.getElementById('player1');
    const p2Area = document.getElementById('player2');
    const fieldArea = document.getElementById('field');

    p1Area.innerHTML = '';
    p2Area.innerHTML = '';
    fieldArea.innerHTML = '';

    this.player1.open.forEach((c, i) => p1Area.appendChild(this.createCardElement(c, 1, i)));
    this.player2.open.forEach((c, i) => p2Area.appendChild(this.createCardElement(c, 2, i)));
    this.field.forEach(c => fieldArea.appendChild(this.createCardElement(c, 0, 0, true)));
    
    document.getElementById('p1-count').textContent = this.player1.hand.length;
    document.getElementById('p2-count').textContent = this.player2.hand.length;

		// ★再描画のたびに、詰んでいないかチェック
    this.checkStalemate();
  }
}

const game = new GameUI();
</script>
